# Java 编程思想

## 面向对象

 	1. 一种语言包括但不限于编程语言，会影响一个人的思维。
 	2. 面向对象是一种对问题的进行抽象的方式。
 	3. 编写程序实际上是建立现实的实际问题与计算机之间的一对一的联系，映射，也可以理解为，以机器能理解的方式，对现实问题进行建模。
 	4. 软件设计 的原则是高内聚低耦合，一个组件或者模块应该提供明确的而又单一的功能，但是这不意味着我们在一个对象中塞入太多的代码，即使有详细的代码注释，当别人看到一个类有几千行的时候也是一种恶噩梦。之前做过一些外包项目，先不说一个类有好几千行，单是多层的嵌套循环，或者一个循环有一千多行就让人头皮发麻。这种项目不仅后期维护起来十分棘手，就是性能问题也是很难解决的（吐糟一下o(╥﹏╥)o）。
 	5. 约定大于配置，这是SpringBoot带给我们的一个理念，虽然省去了不少不少配置，但是实际的应用场景，大部分还是要自定义配置的，个人理解，这种约定更适用于小型的项目，或者方便进行一些简单的开箱即用。
 	6. 通过面向对象建立的模型相对于面向过程的模型更能使开发者理解程序索要执行的动作。
 	7. **封装**，就是隐藏实现，将数据和行为包装成一个数据类型，这个数据类型的内部行为的具体实现细节对外是不公开的。类库或者客户端的使用者无需关系该行为内部是如何实现的，他只需要结合实现的提供者提供的接口和文档，在合适的地方调用即可。另外，封装还有一个好处就是，因为使用者无需关心行为的具体实现细节，在接口不变，以及行为的副作用不变的情况下，即使行为的实现的细节发生了改变，对于使用者来说也不需要变更任何代码。(所以接口上的注释是很重要的，否则使用者仅从方法名或者其他有限的信息无法知道这个行为的副作用是什么╮(￣▽￣)╭)。
 	8. 委派和继承都是对已有代码的复用。继承，强调的是对通用代码的扩展，也就是说，父类代表着最一般的情况，而子类代表着特殊情况，比如说，不管男人女人，都属于人类这一范畴，那么我们可以将人类定义为父类（该类中定义了人类的基本或者说通用的行为和属性），然后男人和女人分别继承人类这一父类，然后在此之上进行扩展，比如说男人和女人的生殖器官的不同等等。而委派强调的是对现有的代码的复用，比如现有的代码无法完成全部需求。举个例子，比如当前有一个功能想要追加日志功能，但是又不想对以前的代码进行变更，那这个委派就是一种很好的实现方式，旧的代码无需更改，只需在此之上进行扩展即可。
 	9. 多态，Java中的多态机制是通过后期绑定（动态绑定）来实现的，即在编译期是无法知道具体的类型，只有在运行时才能知道具体的类型信息。多态可以更好的解耦可变和不可变的部分。
 	10. 构造器的调用顺序，当创建子类的对象的时候，子类的构造函数一定会调用父类的构造函数，其原因是因为，子类可能用到了父类的属性，而如果这些属性没有被正确的初始化，那使用时会出现异常，而构造函数拥有可以生成对象并初始化对象属性的权限，所以需要在子类中调用父类的构造函数来正确的初始化父类。
 	11. 当我们没有手动编写构造函数的时候，编译器会默认生成一个空的构造函数，如果父类没有空的构造函数只有一个有参的构造函数，那编译器就不会自动生成无参的构造函数，那么我们必须手动的在子类当中调用父类的有参构造函数。
 	12. 最顶层的基类是最先被初始化的，因为调用父类的构造函数的代码必须位于子类构造函数的第一行，所以父类的构造函数先于子类被调用，以此类推，不断的回溯，直到回溯到最顶层的基类。
 	13. 属性的初始化时按照声明的属性初始化的，当我们如果要进行清理时，为了防止属性的之间的依赖，清理的时候应该与从与初始化时顺序相反的方向进行清理作业。
 	14. interface关键字用来定义一个接口，实现该接口的所有类都必须完全实现该接口中的所有抽象方法。因此接口更像是一个使用双方互相约定的一个协议（对方法的使用描述，以及这个接口的作用），使用方只要看到接口就知道给即将调用的方法传递什么参数，并且得到怎样的返回值。
 	15. Java不允许多继承，因为多继承存在父类属性互相冲突的问题（好像还有更正式的说法），但Java可以实现多个接口，但是接口中的方法签名是不允许相同的，这个在编译期就会得到错误警告。另外一个点，接口中只允许定义static final类型的常量（默认即为如此）。
 	16. Java中允许接口继承多个接口（因为接口之间不存在属性冲突的可能）。
 	17. 一个接口可以有多个实现，结合策略模式可以使得方法更加灵活通用。另外与接口比较密切的设计模式，比如说，适配器模式，工厂模式。
 	18. 减少过早优化，以需求来驱动重构和抽象化，过早的重构优化会带来不必要的复杂度，可以理解为当项目比庞大的或者复杂度比较高的时候，此时进行重构优化以及抽象化是比较恰当的。

